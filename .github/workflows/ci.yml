name: CI
on:
  workflow_dispatch: {}
  pull_request:
    paths-ignore:
      - '**/collections/**'
      - '**/vendor/**'
      - '**/dist/**'
      - '**/build/**'
      - '**/.venv/**'
      - '**/node_modules/**'
      - '**/.git/**'
  push:
    branches: [main]
    tags:
      - "v*"
    paths-ignore:
      - '**/collections/**'
      - '**/vendor/**'
      - '**/dist/**'
      - '**/build/**'
      - '**/.venv/**'
      - '**/node_modules/**'
      - '**/.git/**'
# Cancel older runs for the same ref to reduce noise/cost.
concurrency:
  group: ci-${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true
permissions:
  contents: read
  packages: read
env:
  # CI container published to GHCR (Option B)
  CI_IMAGE: ghcr.io/${{ github.repository_owner }}/podman-gitops-stack-ci
jobs:
  # Option B: run CI inside a container published to GHCR for faster, consistent toolchains.
  # The Dockerfile is expected at: .github/ci/Dockerfile
  ci-image:
    name: Build/push CI image (GHCR)
    runs-on: ubuntu-latest
    if: ${{ github.event_name == 'workflow_dispatch' || (github.event_name == 'push' && (github.ref == 'refs/heads/main' ||
      startsWith(github.ref, 'refs/tags/v'))) }}
    permissions:
      contents: read
      packages: write
    steps:
      - name: Checkout
        uses: actions/checkout@v4
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
      - name: Log in to GHCR
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}
      - name: Extract Docker metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.CI_IMAGE }}
          tags: |
            type=raw,value=latest
            type=raw,value=sha-${{ github.sha }}
      - name: Build and push
        uses: docker/build-push-action@v6
        with:
          context: .
          file: .github/ci/Dockerfile
          push: ${{ github.event_name == 'push' && (github.ref == 'refs/heads/main' || startsWith(github.ref, 'refs/tags/v'))
            }}
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          platforms: linux/amd64
  # Non-blocking: "nice to have" guardrail to keep commit history tidy.
  # This checks commit SUBJECT lines for a Conventional-Commit-ish pattern.
  # NOTE: Merge commits are ignored.
  commit-message-check:
    name: Commit message check (non-blocking)
    runs-on: ubuntu-latest
    permissions:
      contents: read
    continue-on-error: true
    if: ${{ github.event_name == 'pull_request' || github.event_name == 'push' }}
    steps:
      - name: Checkout (full history for PR ranges)
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
      - name: Validate commit subjects
        shell: bash
        run: |
          set -euo pipefail

          echo "Ref: $GITHUB_REF"
          echo "Event: $GITHUB_EVENT_NAME"

          # Conventional-commit-ish subject line:
          #   type(scope): message
          # scope is optional.
          pattern='^(feat|fix|docs|style|refactor|perf|test|build|ci|chore|revert)(\([^)]+\))?: .+'

          # Determine commit range.
          if [[ "$GITHUB_EVENT_NAME" == "pull_request" ]]; then
            base="${{ github.event.pull_request.base.sha }}"
            head="${{ github.event.pull_request.head.sha }}"
            echo "Checking commits in PR range: $base..$head"
            commits="$(git log --format=%s "$base..$head" || true)"
          else
            # For push, just check the newest commit.
            echo "Checking latest commit on push."
            commits="$(git log -1 --format=%s || true)"
          fi

          if [[ -z "${commits}" ]]; then
            echo "No commits found to check (this can happen on some events)."
            exit 0
          fi

          fail=0
          i=0
          while IFS= read -r subject; do
            i=$((i+1))
            # ignore empty and merge commits
            [[ -z "$subject" ]] && continue
            if [[ "$subject" =~ ^Merge\  ]]; then
              echo "OK  (merge)  $subject"
              continue
            fi
            if [[ "$subject" =~ $pattern ]]; then
              echo "OK          $subject"
            else
              echo "BAD         $subject"
              fail=1
            fi
          done <<< "$commits"

          if [[ "$fail" -ne 0 ]]; then
            echo ""
            echo "Commit message check failed (non-blocking)."
            echo "Expected pattern: $pattern"
            echo "Suggested examples:"
            echo "  feat(ansible): add users role"
            echo "  fix(ci): cache pip installs"
            echo "  docs(readme): update bootstrap instructions"
            exit 1
          fi
  markdown-lint:
    name: Markdown lint
    runs-on: ubuntu-latest
    permissions:
      contents: read
    if: ${{ github.event_name == 'pull_request' || github.event_name == 'push' }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: '20'
      - name: Install markdownlint-cli
        shell: bash
        run: |
          set -euo pipefail
          npm install --global markdownlint-cli
      - name: Run markdownlint
        shell: bash
        run: |
          set -euo pipefail
          if [[ ! -f .markdownlint.yaml ]]; then
            echo ".markdownlint.yaml not found at repo root."
            echo "If you renamed/moved it, update this job accordingly."
            exit 1
          fi
          markdownlint -c .markdownlint.yaml . \
            --ignore collections \
            --ignore vendor \
            --ignore dist \
            --ignore build \
            --ignore node_modules
  bootstrap-ansible:
    name: Bootstrap Ansible (lint + syntax)
    runs-on: ubuntu-latest
    defaults:
      run:
        working-directory: bootstrap/ansible
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
      - name: Log in to GHCR (pull CI image)
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}
      - name: Select CI image tag
        id: ci_tag
        shell: bash
        run: |
          set -euo pipefail
          if [[ "${GITHUB_EVENT_NAME}" == "push" ]]; then
            echo "tag=sha-${GITHUB_SHA}" >> "$GITHUB_OUTPUT"
          else
            echo "tag=latest" >> "$GITHUB_OUTPUT"
          fi
      - name: Ensure CI image is available (pull or build locally)
        shell: bash
        run: |
          set -euo pipefail
          image="${CI_IMAGE}:${{ steps.ci_tag.outputs.tag }}"
          echo "Using CI image: $image"

          if docker pull "$image"; then
            echo "Pulled $image"
          else
            echo "Could not pull $image (likely not published yet). Building locally for this run…"
            docker build -f "$GITHUB_WORKSPACE/.github/ci/Dockerfile" -t "$image" "$GITHUB_WORKSPACE"
          fi
      - name: Debug tool versions (in CI image)
        shell: bash
        run: |
          set -euo pipefail
          image="${CI_IMAGE}:${{ steps.ci_tag.outputs.tag }}"
          docker run --rm -v "$GITHUB_WORKSPACE:/work" -w "/work/bootstrap/ansible" "$image" bash -lc '
            python --version
            pip --version
            ansible --version
            ansible-lint --version
            yamllint --version
            if command -v yamlfmt >/dev/null 2>&1; then yamlfmt --version; else echo "yamlfmt not installed (optional)"; fi
          '
      - name: Install repo dev dependencies (in CI image)
        shell: bash
        run: |
          set -euo pipefail
          image="${CI_IMAGE}:${{ steps.ci_tag.outputs.tag }}"
          docker run --rm -v "$GITHUB_WORKSPACE:/work" -w "/work/bootstrap/ansible" "$image" bash -lc '
            python -m pip install --upgrade pip
            python -m pip install -e "../..[dev]"
            pre-commit install --install-hooks

            echo "[INFO] Verifying dynamic version (setuptools-scm) inside CI image…"
            python -m setuptools_scm
          '
      - name: Install Ansible collections (in CI image)
        shell: bash
        run: |
          set -euo pipefail
          image="${CI_IMAGE}:${{ steps.ci_tag.outputs.tag }}"
          docker run --rm -v "$GITHUB_WORKSPACE:/work" -w "/work/bootstrap/ansible" "$image" bash -lc '
            ansible-galaxy collection install -r collections/requirements.yml
          '
      - name: Run pre-commit checks (in CI image)
        shell: bash
        run: |
          set -euo pipefail
          image="${CI_IMAGE}:${{ steps.ci_tag.outputs.tag }}"
          docker run --rm -v "$GITHUB_WORKSPACE:/work" -w "/work/bootstrap/ansible" "$image" bash -lc '
            cd ../.. && pre-commit run --all-files --show-diff-on-failure
          '
      - name: Ansible syntax check (vault-aware, in CI image)
        shell: bash
        env:
          ANSIBLE_VAULT_PASSWORD: ${{ secrets.ANSIBLE_VAULT_PASSWORD }}
        run: |
          set -euo pipefail
          image="${CI_IMAGE}:${{ steps.ci_tag.outputs.tag }}"

          # Write secret to a temp file on the runner, then mount it.
          pwfile=""
          if [[ -n "${ANSIBLE_VAULT_PASSWORD:-}" ]]; then
            pwfile="$(mktemp)"
            printf '%s' "$ANSIBLE_VAULT_PASSWORD" > "$pwfile"
            chmod 600 "$pwfile"
          fi

          docker run --rm \
            -v "$GITHUB_WORKSPACE:/work" \
            ${pwfile:+-v "$pwfile:/tmp/vault-pass:ro"} \
            -w "/work/bootstrap/ansible" \
            "$image" bash -lc '
              set -euo pipefail
              echo "Scanning for encrypted vault files…"
              candidates=$(ls -1 group_vars/**/*.yml group_vars/**/*.yaml 2>/dev/null || true)
              encrypted=0
              while IFS= read -r f; do
                [[ -z "$f" ]] && continue
                if head -n 1 "$f" | grep -q '^\$ANSIBLE_VAULT;'; then
                  echo "Encrypted vault detected: $f"
                  encrypted=1
                fi
              done <<< "$candidates"

              if [[ "$encrypted" -eq 1 ]]; then
                if [[ -f /tmp/vault-pass ]]; then
                  echo "Vault password provided. Running syntax-check with vault password."
                  ansible-playbook --syntax-check site.yml --vault-password-file /tmp/vault-pass
                else
                  echo "Encrypted vault files detected, but no ANSIBLE_VAULT_PASSWORD secret is set."
                  echo "Skipping syntax-check to avoid hard-failing CI. (Set the secret to enable this.)"
                  exit 0
                fi
              else
                echo "No encrypted vault files detected. Running syntax-check."
                ansible-playbook --syntax-check site.yml
              fi
            '

          # Cleanup temp file if created.
          if [[ -n "$pwfile" ]]; then rm -f "$pwfile"; fi
  python-sanity:
    name: Python sanity (ruff + pytest)
    runs-on: ubuntu-latest
    if: ${{ hashFiles('pyproject.toml', 'orchestration/**/*.py', 'tests/**') != '' }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
      - name: Log in to GHCR (pull CI image)
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}
      - name: Select CI image tag
        id: ci_tag
        shell: bash
        run: |
          set -euo pipefail
          if [[ "${GITHUB_EVENT_NAME}" == "push" ]]; then
            echo "tag=sha-${GITHUB_SHA}" >> "$GITHUB_OUTPUT"
          else
            echo "tag=latest" >> "$GITHUB_OUTPUT"
          fi
      - name: Ensure CI image is available (pull or build locally)
        shell: bash
        run: |
          set -euo pipefail
          image="${CI_IMAGE}:${{ steps.ci_tag.outputs.tag }}"
          echo "Using CI image: $image"

          if docker pull "$image"; then
            echo "Pulled $image"
          else
            echo "Could not pull $image (likely not published yet). Building locally for this run…"
            docker build -f "$GITHUB_WORKSPACE/.github/ci/Dockerfile" -t "$image" "$GITHUB_WORKSPACE"
          fi
      - name: Install repo dev dependencies + run checks (in CI image)
        shell: bash
        run: |
          set -euo pipefail
          image="${CI_IMAGE}:${{ steps.ci_tag.outputs.tag }}"
          docker run --rm -v "$GITHUB_WORKSPACE:/work" -w "/work" "$image" bash -lc '
            python -m pip install --upgrade pip
            python -m pip install -e ".[dev]"
            pre-commit install --install-hooks

            echo "[INFO] Verifying dynamic version (setuptools-scm) inside CI image…"
            python -m setuptools_scm

            echo "[INFO] Running all pre-commit checks..."
            pre-commit run --all-files --show-diff-on-failure

            echo "[INFO] Running Python tests..."
            pytest -q || true
          '
  # Release-only: validate that CHANGELOG.md matches git-cliff output for the tag being pushed.
  # This is a "confidence check" so releases don't ship with stale notes.
  release-changelog:
    name: Release changelog check (git-cliff)
    runs-on: ubuntu-latest
    permissions:
      contents: read
    if: ${{ github.event_name == 'push' && startsWith(github.ref, 'refs/tags/v') }}
    steps:
      - name: Checkout (full history + tags)
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
      - name: Generate changelog with git-cliff
        uses: orhun/git-cliff-action@v3
        with:
          config: cliff.toml
          args: -o CHANGELOG.generated.md
      - name: Compare generated changelog to repo CHANGELOG.md
        shell: bash
        run: |
          set -euo pipefail
          if [[ ! -f CHANGELOG.md ]]; then
            echo "CHANGELOG.md not found in repo root."
            echo "If you intentionally keep it elsewhere, update this workflow accordingly."
            exit 1
          fi

          # Normalize line endings just in case.
          sed -i 's/\r$//' CHANGELOG.generated.md
          sed -i 's/\r$//' CHANGELOG.md

          if diff -u CHANGELOG.md CHANGELOG.generated.md; then
            echo "Changelog matches git-cliff output."
          else
            echo ""
            echo "CHANGELOG.md does NOT match git-cliff output for this repo state."
            echo "Fix by running git-cliff and committing the updated CHANGELOG.md before tagging."
            exit 1
          fi
